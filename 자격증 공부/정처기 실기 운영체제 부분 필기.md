# 정보처리기능사 실기 대비 필기 - 운영체제 부분

## 01. 응용 SW 기초 기술 활용

### 01. 운영체제 기초 활용

#### 01. 운영체제의 개요

**01. 운영체제의 개념**

운영체제(OS, Operating System)는 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종이다.

컴퓨터를 편리하게 사용하고 컴퓨터 하드웨어를 효율적으로 사용할 수 있게 한다.



**02. 운영체제의 목적 = 운영체제의 성능 평가 항목**

* 처리 능력(Throughput) 향상 : 주어진 시간 내에 처리되는 작업의 양. 작업량이 많을수록 운영체제의 성능이 좋은 것임.
* 응답 시간(Turnaround Time) 감소 : 컴퓨터에 명령을 지시하고 그 결과가 출력되는 시간. 응답시간이 짧을수록 운영체제의 성능이 좋은 것임.
* 신뢰성(Reliability) 향상 : 주어진 작업에 대해 얼마나 오류없이 처리하는지에 대한 것.
* 사용 가능도(Availability) 향상 : 시스템 운영 시간 중 얼마나 많은 시간을 사용 가능한지에 대한 것.



**03. 운영체제의 기능**

사용자와 컴퓨터 시스템 간의 인터페이스 제공.

프로세서, 기억장치, 입출력장치, 파일 및 정보 등의 자원 관리.

입출력에 대한 보조기능 제공.



**04. 운영체제의 운영 방식**

* **일괄 처리 시스템(Batch Processing System)**

  시대적으로 가장 먼저 생겨난 형태로 한정된 시간 제약조건에서 분석하여 처리하는 시스템.

  예시 : 수도요금 계산 업무, 월급 계산 업무, 연말 결산 업무.

  

* **다중 프로그래밍 시스템(Multi-Programming System)**

  하나의 컴퓨터 시스템에서 여러 프로그램들이 같이 입력되어 주기억장치에 적재되고, 처리장치를 번갈아 사용하며 실행하는 시스템.

  처리량 극대화 시킴.

  

* **시분할 시스템(Time Sharing System)**

  하나의 컴퓨터를 여러 개의 단말기가 공동으로 사용하게 하는 시스템.

  

* **다중 처리 시스템(Multi-Processing System)**

  여러 개의 CPU와 한 개의 주기억장치로 동시에 처리하는 시스템.

  

* **실시간 처리 시스템(Real Time Processing Time) **

  처리해야 할 작업이 발생한 시점에서 즉각으로 처리해 그 결과를 얻어내는 시스템. **<u>정해진 시간</u>** 에 반드시 수행되어야 하는 작업들을 처리하기에 적합함.

  예시 : 항공기 예약 업무, 은행 창구 업무, 조회 및 질의 업무.

  

* **다중 모드 시스템(Multi-Mode System)**

  일괄 처리, 시분할, 다중 처리, 실시간 처리 시스템을 한 시스템에서 모두 제공하는 시스템.



* **분산 처리 시스템(Distributed Processing System)**

  여러 컴퓨터들에 의해 작업들을 나눠 처리하여 그 내용이나 결과를 통신망을 이용해 상호 교환이 되도록 연결되있는 시스템.





**05. 운영체제의 발달 과정**

일괄 처리 시스템 -> 다중 프로그래밍, 시분할 다중 처리, 실시간 시스템 -> 다중 모드 시스템 -> 분산 처리 시스템





#### 02. 주 메모리 관리

**01. 기억장치의 분류**

기억장치는(Memory)는 중앙처리장치(CPU)가 작업을 수행하기 위해서 프로그램이나 데이터를 일시적으로 혹은 영구히 저장하는 장치를 통틀어 지칭한다.

하드디스크와 같은 보조기억장치는 대용량 데이터를 저장하고 있다가 주기억장치로 데이터를 전송하고, CPU의 레지스터는 주기억장치 또는 캐시 기억장치로부터 데이터를 읽어들인다.

**메모리 계층도**

![메모리_계층_구조](/Users/cho1111/Desktop/메모리_계층_구조.png)

**02. 기억장치의 특징**

* **주 메모리(Main Memory ,주기억장치)**

  CPU가 직접 접근해 처리할 수 있는 기억장치로 현재 수행 중인 프로그램과 데이터를 저장함.

  

* **캐시 메모리(Cache Memory)**

  주기억장치와 CPU의 속도 차이를 줄여 처리 효율을 높이기 위한 목적으로 사용됨.

  

* **연관 메모리(Associative Memory)**

  저장된 내용을 이용해 접근하는 기억장치로 CAM(Content Addressable Memory)이라고도 함.

  

* **보조 메모리(Secondary Memory)**

  주기억장치의 부족한 용량 문제를 해결하기 위해 외부에 설치된 대용량 기억장치.

  주기억장치에 비해 접근 속도가 느림.

  

* **가상 메모리(Virtual Memory)**

  주기억장치의 부족한 용량을 해결하기 위해 **<u>보조기억장치를 주기억장치처럼 사용</u>** 하는 기법.

  가상 메모리의 구현 기법으로 **<u>페이징(paging)</u>** 기법과 **<u>세그먼테이션(segmentation)</u>** 기법이 있음.



**03. 기억장치의 관리 전략**

* **반입(Fetch) 전략 : When**

  프로그램/데이터를 주기억장치로 가져오는 시기를 결정하는 전략.

  종류 : **<u>요구 반입</u>** , **<u>예상 반입</u>**



* **배치(Placement) 전략 : Where**

  프로그램/데이터의 주기억장치 내의 위치를 정하는 전략.

  

* **교체(Replacement) 전략 : Who/What**

  주기억장치 내의 빈 공간 확보를 위해 제거할 프로그램/데이터를 선택하는 전략.

  종류 : **<u>FIFO</u>**, **<u>OPT</u>**, **<u>LRU</u>**, **<u>LFU</u>**, **<u>NUR</u>**, **<u>SCR</u>**





**04. 배치(Placement) 전략**

|      배치 전략       |                             설명                             |
| :------------------: | :----------------------------------------------------------: |
| 최초 적합(First Fit) | 적재 가능한 공간 중에 **<u> 첫 번째 공간에 배치</u>** 하는 방식이다. |
| 최적 적합(Best Fit)  | 단편화 공간이 **<u>가장 작게 발생하는 공간</u>** 에 배치하는 방식이다. |
| 최악 적합(Worst Fit) | 단편화 공간이 **<u>가장 크게 발생하는 공간</u>** 에 배치하는 방식 |





**05. 단편화**

* **단편화(Fragmentation)**

  주기억장치 상에서 빈번하게 기억 장소가 할당되고 반납됨에 따라 기억장소들이 조각들로 나눠지는 현상.

  종류 : 내부 단편화(Internal Fragmentation), 외부 단편화(External Fragmentation)

  * <u>내부 단편화</u> : **<u>분할된 영역이 할당 작업보다 큰 상황</u>** 에서 할당된 후 남게 되는 빈 조각 공간이 발생하는 현상.

  * <u>외부 단편화</u> : **<u>분할된 영역이 할당 작업보다 작은 상황</u>** 에서 할당이 불가능하게 되어 남게 되는 공간이 발생하는 현상.



* **단편화 해결 방법**

  분할된 주기억장치의 공간을 재사용 하도록 하나로 모아 사용 할 수 있는 공간으로 만드는 기법.

  종류 : 통합, 압축

  <u>통합(Coalescing)</u> : **<u>인접한 낭비 공간들을 모아서</u>** 하나의 큰 기억 공간을 만드는 작업.

  <u>압축(Compaction)</u> : **<u>서로 떨어져 있는 공백을 모아서</u>** 하나의 큰 기억 공간을 만드는 작업. **가비지 컬렉션(쓰레기 수집, Garbage Collection)** 이라고도 함.

  



#### 03. 가상 메모리 관리

**01. 가상 메모리**

가상기억장치(Virtual Memory) 는 **<u>보조기억장치의 일부를 주기억장치</u>** 처럼 사용하는 것으로, 주기억장치보다 큰 용량의 프로그램을 처리하기 위해 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법.

가상기억장치에 저장된 프로그램을 실행하기 위해 **<u>가상기억장치의 주소를 주기억장치의 주소로 변환하는 주소 변환</u>** (매핑, Mapping) 작업이 필요함.

페이징 기법과 세그먼테이션 기법이 있음.



* **페이징(Paging) 기법**

  **<u>가상기억장치에 보관된 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후</u>**, 나눠진 프로그램(페이지, Page)을 동일하게 나눠진 주기억장치의 영역(Page Frame)에 적재시켜 실행하는 기법.

  가상기억장치에서 주기억장치로 주소를 조정하는 매핑(Mapping)을 위해 **<u>페이지의 위치 정보를 가진</u>** 페이지 맵 테이블(Page Map Table)이 필요함.

  외부 단편화는 발생하지 않지만, 내부 단편화가 발생할 수 있음.

  **<u>페이지의 크기가 클수록</u>** 페이지 맵 테이블의 크기가 작아지고, 단편화가 증가하고, 디스크 접근 횟수가 감소하며, 전체 입출력 시간이 감소함. (부정)

  **<u>페이지의 크기가 작을수록</u>** 페이지 맵 테이블의 크기가 커지고, 단편화가 감소하고, 디스크 접근 횟수가 증가하며, 전체 입출력 시간이 증가함. (긍정)

  

* **세그먼테이션(Segmentation) 기법**

  가상기억장치에 보관된 프로그램을 다양한 크기의 논리적 단위(세그먼트, Segment)로 나눈 후 주기억장치에 적재시켜 실행시키는 기법.

  매핑(Mapping)을 위해 **<u>세그먼트의 위치 정보를 가진</u>** 세그먼트 맵 테이블(Segment Map Table) 이 필요함.

  외부 단편화가 발생할 수 있음.





**02. 매핑 테이블**

매핑(mapping, 사상) 작업은 **<u>논리적 주소와 물리적 주소를 연결</u>** 하는 과정으로 하드웨어 장치인 MMU(Memory Management Unit, 메모리 관리 장치) 에 의해 실행됨. 논리적 주소와 물리적 주소의 매핑 정보를 매핑 테이블에 저장하여 관리하게 됨.



**03. 페이지 교체 알고리즘**

프로세스 실행 시 참조할 페이지가 주기억장치에 없는 페이지 부재(Page Fault) 발생 시 가상기억장치의 페이지를 주기억장치에 적재해야 하는데, 주기억장치의 모든 프레임이 사용 중이면, 어떤 페이지 프레임을 교체할지 결정하는 기법.

|            교체 알고리즘             |                             설명                             |
| :----------------------------------: | :----------------------------------------------------------: |
| OPT<br />(OPTimal page replacement)  | 이후에 **<u>가장 오랫동안 사용되지 않을</u>** 페이지를 먼저 교체하는 기법.<br />실현 가능성이 희박함. |
|    FIFO<br />(First In First Out)    | **<u>가장 먼저 적재된</u>** 페이지를 먼저 교체하는 기법.<br />벨레이디의 모순(Belady's Anomaly) 현상이 발생함. |
|    LRU<br />(Least Recently Used)    | **<u>가장 오랫동안 사용되지 않았던</u>** 페이지를 먼저 교체하는 기법. |
|   LFU<br />(Least Frequently Used)   | **<u>참조된 횟수가 가장 적은</u>** 페이지를 먼저 교체하는 기법. |
|     NUR<br />(Not Used Recently)     | **<u>최근에 사용되지 않은</u>** 페이지를 먼저 교체하는 기법. |
| SCR<br />(Second Chance Replacement) | 각 페이지에 프레임을 **<u>FIFO 순으로 유지하면서 LRU 근사 알고리즘 처럼</u>** 참조 비트를 갖게하는 기법. |





**04. 가상기억장치 관련 기타 주요 용어**

* **구역성(Locality, 지역성)**

  프로세스가 실행되는 동안 일부 페이지만 **<u>집중적으로 참조되는</u>** 경향을 의미함.

  캐시 메모리 시스템의 이론적 근거가 되고 스래싱을 방지하기 위한 워킹 셋 이론의 기반이 됨.

  <u>시간 구역성(Temporal Locality)</u> : **<u>최근에 참조된 기억장소가</u>** 가까운 장래에도 계속 참조될 가능성이 높음을 의미함. (루프, 서브루틴, 스택, 집계에 사용되는 변수 등.)

  <u>공간 구역성(Spatial Locality)</u> : **<u>하나의 기억장소가</u>** 가까운 장래에도 계속 참조될 가능성이 높음을 의미함. (배열 순례, 프로그램의 순차적 수행 등.)

  

* **워킹 셋(Working Set)**

  프로세스를 효과적으로 실행하기 위해 주기억장치에 유지되어야 하는 페이지의 집합.
  
* **스래싱(Thrashing)**

  페이지 부재가 계속 발생해 프로세스가 수행되는 시간보다 페이지 교체에 시간이 더 많이 드는 현상.

  스레싱 현상 방지 기법: 

  CPU 이용률을 증가.

  페이지 부재율 조절 후 대처.

  워킹 셋 방법을 사용.

  

* **페이지 부재(Page Fault)**

  참조할 페이지가 주기억장치에 없는 현상.

  페이지 부재율에 따라  **<u>주기억장치에 있는 페이지 프레임의 수를</u>** 조절하여 페이지 부재율을 정상적으로 유지하는 것이 바람직함.





#### 04. 프로세스 스케줄링

**01. 프로세스(Process)의 개념**

프로세스는 운영체제가 관리하는 실행의 단위로 실행 중인 프로그램이라고 함.

프로세서가 할당하는 실체.

프로시저가 활동 중인 것.

PCB를 가진 프로그램.



**02. 프로세스 제어 블록(PCB: Process Control Block)**

운영체제가 프로세스에 대한 중요한 정보를 저장해 놓을 수 있는 저장 장소.

각 프로세스는 고유한 PCB를 가짐. 프로세스가 생성될 때 고유의 PCB가 생성되고, 종료되면 PCB는 제거됨.

PCB에 저장되어 있는 정보: 

프로세스의 현재 상태

프로세스의 우선 순위

CPU 레지스터 정보

할당된 자원에 대한 정보

프로세스 고유 식별자(PID)

입/출력 상태 정보

각종 자원의 포인터



**03. 프로세스 상태 전이**

![프로세스 상태 전이](/Users/cho1111/Desktop/프로세스 상태 전이.png)



* **준비(Ready) 상태**

  CPU를 할당받기 위해 기다리고 있는 상태

  

* **실행(Running) 상태**

  준비 큐에 있는 프로세스가 CPU를 할당받아 실행되는 상태로 CPU 스케줄러에 의해 수행됨.

  

* **대기(Block) 상태**

  프로세스가 입/출력 처리가 필요하면 현재 수행 중인 프로세스가 입/출력을 위해 대기 상태로 전이됨.

  대기 중인 프로세스는 입/출력이 완료되면 대기 상태에서 준비 상태로 전이됨.





**04. 스레드(Thread)의 개념**

제어의 흐름을 뜻하며 프로세스에서 실행의 개념만을 분리한 것으로 프로세스의 일부 특성을 가져서 **<u>경량(light weight)</u>** 프로세스 라고도 함.





**05. 프로세스 스케줄링**

* **프로세스 스케줄링(Scheduling)의 개념**

  프로세스의 생성 및 실행에 필요한 자원을 해당 프로세스에 할당하는 것을 뜻함.

  스케줄링의 기법은 **<u>비선점 기법</u>** 과 **<u>선점 기법</u>** 으로 구분할 수 있음.

  

* **프로세스 스케줄링의 목적**

  모든 작업들에 대해 공정성을 유지하기 위한 방법.

  단위 시간당 처리량을 최대화.

  응답, 반환, 대기 시간 및 오버헤드를 최소화.

  

* **비선점(Non-preemptive) 스케줄링**

  CPU를 할당받으면 다른 프로세스가 CPU를 강제적으로 뺏지 못하는 방식.

  모든 프로세스에 대한 공정한 처리가 가능.

  일괄 처리 시스템에 적합함.

  

* **선점(Preemptive) 스케줄링**

  한 프로세스가 CPU를 할당받아 실행 중이여도 우선순위가 높은 프로세스가 CPU를 강제로 뺏을 수 있는 방식.

  높은 우선순위의 프로세스들이 빠르게 처리 될 수 있음.

  대화식 시분할 시스템에 적합함.





**06. 비선점(Non-preemptive) 스케줄링 종류**

|                  기법                  |                             설명                             |
| :------------------------------------: | :----------------------------------------------------------: |
|  FCFS<br />(First Come First Service)  | **<u>준비상태 큐에 도착한 순서</u>** 로 CPU를 할당하는 기법. |
|     SJF<br />(Shortest Job First)      | 준비상태 큐에서 대기하는 프로세스들 중 **<u>실행 시간이 가장 짧은</u>** 프로세스에게 먼저 CPU를 할당하는 기법.<br />평균 대기 시간을 최소화. |
| HRN<br />(Highest Response-ratio Next) | 작업이 서비스 받을 시간과 그 작업이 서비스를 기다린 시간으로 결정되는 우선순위로 CPU를 할당하는 기법.<br />우선순위 계산식 = **<u>(대기시간 + 서비스 시간) / 서비스 시간</u>** |
|            기한부(Deadline)            | 작업이 주어진 특별한 시간이나 만료시간 안에 완료하게 하는 기법. |
|           우선순위(Priority)           | 준비상태 큐에서 대기하는 프로세스에게 받은 **<u>우선순위가 가장 높은</u>** 프로세스에게 먼저 CPU를 할당받는 기법. |





**07. 선점(Preemptive) 스케줄링 종류**

|                       기법                        |                             설명                             |
| :-----------------------------------------------: | :----------------------------------------------------------: |
|        SRT<br />(Shortest Remaining Time)         | 실행 중인 프로세스의 남은 시간과 준비상태 큐에 새로 도착한 프로세스의 실행 시간을 비교해 **<u>실행 시간이 더 짧은 프로세스</u>** 에게 CPU를 할당하는 기법.<br />시분할 시스템에 유용함. |
|                  RR(Round Robin)                  | 주어진 시간 할당량 안에 작업을 안 마치면 준비완료 리스트의 맨 뒤로 배치되는 기법. |
|         다단계 큐(MQ, Multi level Queue)          |   상위, 중위, 하위 단계의 단계별 준비 큐를 배치하는 기법.    |
| 다단계 피드백 큐(MFQ, Multi-level Feedback Queue) | 각 준비상태 큐마다 받은 시간 할당량 안에 완료하지 못한 프로세스는 다단계의 준비 상태 큐로 이동하는 기법. |





**08. 문맥교환(Context Switching)**

앞으로 실행될 프로세스의 상태 정보를 설정한 후 중앙처리장치를 할당해 실행을 되게 하는 작업을 말함.





**09. 병행 프로세스**

두 개 이상의 프로세스들이 동시에 실행 상태에 있는 것을 뜻함.

여러 프로세스들이 독립적으로 실행되는 것을 독립적 병행 프로세스라고 하고, 서로 협력하며 동시에 실행되는 것을 병행 프로세스 라고함.

<u>임계 구역(Critical Section)</u> : 다중 프로그래밍에서 여러 개의 프로세스가 공유하는 자원, 데이터에 대해 한 시점에서 하나의 프로세스만 사용할 수 있도록 지정된 공유자원.
<u>동기화 기법(Synchronization)</u> : 두 개 이상의 프로세스를 한 시점에서 동시에 처리할 수 없어서 각 프로세스에 대해 처리 순서를 결정하는 것으로 상호배제의 한 형태.





**10. 교착 상태(DeadLock)**

* **교착 상태의 개념**

  상호배제에 의해 나타나는 문제점으로 두 개 이상의 프로세스들이 자원을 점유한 상태에서 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상.

  

* **교착 상태의 발생 조건**

  * **상호 배제(Mutual Exculsion)**

  * **점유 및 대기(Hold and Wait)**

  * **비선점(Non-Preemption)**

  * **환형 대기(Circular Wait)**

    

* **교착 상태의 해결 방법**

  * **예방(Prevention)**
  * **회피(Avoidance)**
  * **발견(Detection)**
  * **회복(Recovery)**







#### 06. 운영체제의 종류 및 Shell Script

**01. 운영체제의 종류**

* **Windows의 특징**

  * 마이크로소프트사에서 발표하고 있는 컴퓨터 운영체제.

  * GUI(Graphic User Interface) 기반 선점형 멀티태스킹 수행.

  * PnP(Plug and Play) 지원.

  * OLE(Object Linking and Embedding) 지원.

    

* **Ms-DOS(Microsoft Disk Operating System)**

  * CUI(Character User Interface) 기반, Single-User, Sigle-Tasking의 특징을 가짐.

  * 트리 구조 파일 시스템.

  * MS-DOS 명령어

    * 내부 명령어 : 명령어 처리 루틴이 메모리에 상주하는 명령아

      예시 : **<u>DIR</u>**, **<u>COPY</u>**, **<u>DEL</u>**, **<u>TYPE</u>**, **<u>CLS</u>** 등

    * 외부 명령어 : 디스크에 파일로 저장된 명령어

      예시 : **<u>FORMAT</u>**, **<u>DISKCOPY</u>**, **<u>DISKCOMP</u>**

      

* **유닉스(UNIX) 시스템의 특징**

  * AT&T사의 Bell연구소에서 1960년대 후반에 개발한 운영체제.

  * 이식성이 높고 대화식 운영체제.

  * C언어로 커널까지 작성된 운영체제.

  * 파일 생성, 삭제, 보호 기능을 가지며, 디렉토리 구조는 트리 구조 형태.

    

* **리눅스(LINUX)의 특징**

  * 오픈소스 컴퓨터 운영체젲로 UNIX와의 호환이 완벽함.
  * 허가권과 소유권의 권한을 가짐.





**02. UNIX의 개요**

* **유닉스(UNIX)의 특징**

  * 대화식 운영체제.

  * 이식성과 확장성이 높음.

  * 네트워킹 시스템.

  * 계층적 파일 시스템.

    

* **유닉스(UNIX)의 구성**

  ![유닉스 구성요소](/Users/cho1111/Desktop/유닉스 구성요소.jpeg)



* **커널(Kernel)**

  프로세스, 기억장치, 입/출력, 파일 관리, 시스템 호출 인터페이스 등의 기능을 담당함.

  

* **쉘(Shell)**

  * 명령어 해석기(Interpreter).
  * 사용자의 명령을 인식하고 명령을 수행하는 기능을 담당.

  

  

  




**03. UNIX의 파일 시스템**

UNIX 파일 시스템의 디렉토리 구조는 트리구조.

|  블록 구조  |                             설명                             |
| :---------: | :----------------------------------------------------------: |
|  부트 블록  |              부팅에 필요한 코드를 저장하는 블록              |
|  슈퍼 블록  |         전체 파일 시스템에 대한 정보를 저장하는 블록         |
| I-node 블록 | 각 파일에 대한 정보를 저장함.<br />파일 소유자의 식별 번호, 파일 크기, 파일의 생성 시간, 파일의 최종 수정 시간, 파일의 링크 수 등이 기록됨 |
| 데이터 블록 |               실제 데이터를 저장하고 있는 블록               |

